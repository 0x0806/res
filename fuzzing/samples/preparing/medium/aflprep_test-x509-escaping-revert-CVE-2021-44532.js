'use strict';
if (!common.hasCrypto)
  common.skip('missing crypto');
const assert = require('assert');
const { X509Certificate } = require('crypto');
const tls = require('tls');
const { hasOpenSSL3 } = common;
{
  const expectedSANs = [
    'DNS:good.example.com, DNS:evil.example.com',
    'DNS:exï¿½mple.com',
    'DNS:"evil.example.com"',
    'IP Address:8.8.8.8',
    'IP Address:8.8.4.4',
    hasOpenSSL3 ? 'IP Address:<invalid length=5>' : 'IP Address:<invalid>',
    hasOpenSSL3 ? 'IP Address:<invalid length=6>' : 'IP Address:<invalid>',
    'IP Address:A0B:C0D:E0F:0:0:0:7A7B:7C7D',
    'email:foo@example.com',
    'email:foo@example.com, DNS:good.example.com',
      'evil.example.com',
      'evil.example.com',
    hasOpenSSL3 ?
    'Registered ID:sha256WithRSAEncryption',
    'Registered ID:1.3.9999.12.34',
    hasOpenSSL3 ?
      'othername: XmppAddr::abc123' :
      'othername:<unsupported>',
    hasOpenSSL3 ?
      'othername: XmppAddr::abc123, DNS:good.example.com' :
      'othername:<unsupported>',
    hasOpenSSL3 ?
      null :
      'othername:<unsupported>',
    hasOpenSSL3 ?
      'othername: 1.3.9999.12.34::abc123' :
      'othername:<unsupported>',
    hasOpenSSL3 ? 'othername: SRVName::abc123' : 'othername:<unsupported>',
    hasOpenSSL3 ?
      null : 'othername:<unsupported>',
    hasOpenSSL3 ?
      null :
      'othername:<unsupported>',
  ];
  for (let i = 0; i < expectedSANs.length; i++) {
    const cert = new X509Certificate(pem);
    assert.strictEqual(cert.subjectAltName, expectedSANs[i]);
    const server = tls.createServer({
      key: serverKey,
      cert: pem,
    }, common.mustCall((conn) => {
      conn.destroy();
      server.close();
    })).listen(common.mustCall(() => {
      const { port } = server.address();
      tls.connect(port, {
        ca: pem,
        servername: 'example.com',
        checkServerIdentity: (hostname, peerCert) => {
          assert.strictEqual(hostname, 'example.com');
          assert.strictEqual(peerCert.subjectaltname, expectedSANs[i]);
        },
      }, common.mustCall());
    }));
  }
}
{
  const expectedInfoAccess = [
    {
      legacy: {
        'OCSP - URI': [
        ],
      },
    },
    {
            'OCSP - DNS:good.example.com\n' +
      legacy: {
        'CA Issuers - URI': [
        ],
        'OCSP - DNS': [
          'good.example.com',
        ],
        'OCSP - URI': [
        ],
      },
    },
    {
      legacy: {
        '1.3.9999.12.34 - URI': [
        ],
      },
    },
    hasOpenSSL3 ? {
      text: 'OCSP - othername: XmppAddr::good.example.com\n' +
            'OCSP - othername: 1.3.9999.12.34::abc123\n' +
            'OCSP - othername: SRVName::abc123',
      legacy: {
        'OCSP - othername': [
          ' XmppAddr::good.example.com',
          ' 1.3.9999.12.34::abc123',
          ' SRVName::abc123',
        ],
      },
    } : {
      text: 'OCSP - othername:<unsupported>\n' +
            'OCSP - othername:<unsupported>\n' +
            'OCSP - othername:<unsupported>',
      legacy: {
        'OCSP - othername': [
          '<unsupported>',
          '<unsupported>',
          '<unsupported>',
        ],
      },
    },
    hasOpenSSL3 ? {
      text: null,
      legacy: null,
    } : {
      text: 'OCSP - othername:<unsupported>',
      legacy: {
        'OCSP - othername': [
          '<unsupported>',
        ]
      },
    },
  ];
  for (let i = 0; i < expectedInfoAccess.length; i++) {
    const expected = expectedInfoAccess[i];
    const cert = new X509Certificate(pem);
    assert.strictEqual(cert.infoAccess, expected.text ?
      `${expected.text}${hasOpenSSL3 ? '' : '\n'}` :
      expected.text);
    const server = tls.createServer({
      key: serverKey,
      cert: pem,
    }, common.mustCall((conn) => {
      conn.destroy();
      server.close();
    })).listen(common.mustCall(() => {
      const { port } = server.address();
      tls.connect(port, {
        ca: pem,
        servername: 'example.com',
        checkServerIdentity: (hostname, peerCert) => {
          assert.strictEqual(hostname, 'example.com');
          assert.deepStrictEqual(peerCert.infoAccess,
                                 expected.legacy ?
                                   Object.assign(Object.create(null),
                                                 expected.legacy) :
                                   expected.legacy);
        },
      }, common.mustCall());
    }));
  }
}
{
  const invalidJSON = [
    '"\\a invalid escape"',
    '"\\v invalid escape"',
    '"\\\' invalid escape"',
    '"\\x42 invalid escape"',
    '"\\u202 invalid escape"',
    '"\\012 invalid escape"',
    '"Unterminated string',
    '"Unterminated string\\"',
    '"Unterminated string\\\\\\"',
    '"\u0000 control character"',
    '"\u001e control character"',
    '"\u001f control character"',
  ];
  for (const invalidStringLiteral of invalidJSON) {
    assert.throws(() => {
      tls.checkServerIdentity('example.com', {
        subjectaltname: `DNS:${invalidStringLiteral}`,
      });
    }, {
      code: 'ERR_TLS_CERT_ALTNAME_FORMAT',
      message: 'Invalid subject alternative name string'
    });
  }
}
{
  const san = 'DNS:"a.example.com, DNS:b.example.com, DNS:c.example.com"';
  const hostname = 'b.example.com';
  assert.strictEqual(san.split(', ')[1], `DNS:${hostname}`);
  const err = tls.checkServerIdentity(hostname, { subjectaltname: san });
  assert(err);
  assert.strictEqual(err.code, 'ERR_TLS_CERT_ALTNAME_INVALID');
                                  'altnames: Host: b.example.com. is not in ' +
                                  'the cert\'s altnames: DNS:"a.example.com, ' +
                                  'DNS:b.example.com, DNS:c.example.com"');
}
{
  const key = fixtures.readKey('incorrect_san_correct_subject-key.pem');
  const cert = fixtures.readKey('incorrect_san_correct_subject-cert.pem');
  const servername = 'good.example.com';
  const certX509 = new X509Certificate(cert);
  assert.strictEqual(certX509.subject, `CN=${servername}`);
  assert.strictEqual(certX509.subjectAltName, 'DNS:evil.example.com');
  const server = tls.createServer({ key, cert }, common.mustNotCall());
  server.listen(common.mustCall(() => {
    const { port } = server.address();
    const socket = tls.connect(port, {
      ca: cert,
      servername,
    }, common.mustNotCall());
    socket.on('error', common.mustCall((err) => {
      assert.strictEqual(err.code, 'ERR_TLS_CERT_ALTNAME_INVALID');
                                      "certificate's altnames: Host: " +
                                      "good.example.com. is not in the cert's" +
                                      ' altnames: DNS:evil.example.com');
    }));
  })).unref();
}
{
  const key = fixtures.readKey('irrelevant_san_correct_subject-key.pem');
  const cert = fixtures.readKey('irrelevant_san_correct_subject-cert.pem');
  const servername = 'good.example.com';
  const certX509 = new X509Certificate(cert);
  assert.strictEqual(certX509.subject, `CN=${servername}`);
  assert.strictEqual(certX509.subjectAltName, 'IP Address:1.2.3.4');
  const server = tls.createServer({ key, cert }, common.mustCall((socket) => {
    socket.destroy();
    server.close();
  })).listen(common.mustCall(() => {
    const { port } = server.address();
    tls.connect(port, {
      ca: cert,
      servername,
    }, common.mustCall(() => {
    }));
  }));
}
